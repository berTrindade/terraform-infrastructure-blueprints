# Contributing to Blueprint Template Generator

This guide explains how to contribute to the blueprint template generator by creating new manifests and templates.

## Table of Contents

- [Creating New Manifests](#creating-new-manifests)
- [Creating New Templates](#creating-new-templates)
- [Naming Conventions](#naming-conventions)
- [Variable Structure](#variable-structure)
- [Template Conventions](#template-conventions)
- [Validation Checklist](#validation-checklist)

## Creating New Manifests

### Step 1: Choose Blueprint

Identify the blueprint you want to create a manifest for. Manifests are located in `blueprints/manifests/{blueprint-name}.yaml`.

### Step 2: Analyze Blueprint Structure

Examine the blueprint's modules to identify extractable snippets:
- Look in `modules/` directory
- Identify reusable components (e.g., DynamoDB table, Lambda function, RDS module)
- Note dependencies between modules

### Step 3: Create Manifest File

Create `blueprints/manifests/{blueprint-name}.yaml` with this structure:

```yaml
# Blueprint Manifest: {blueprint-name}
# {Description}
name: {blueprint-name}
description: {Description}
version: 1.0.0

snippets:
  - id: {snippet-id}
    name: {Snippet Name}
    description: {What this snippet does}
    template: {template-name}.tf.template
    output_file: {path/to/output.tf}
    variables:
      - name: {variable_name}
        type: {string|number|boolean}
        required: {true|false}
        default: {value}  # optional
        description: {Description}
        pattern: {regex}  # optional, for strings
        enum: [...]  # optional, for strings/numbers
```

### Step 4: Define Variables

For each snippet, define variables based on:
- Required parameters from the original Terraform code
- Common configuration options
- Sensible defaults for optional parameters

**Variable Types:**
- `string`: Text values (e.g., names, IDs, ARNs)
- `number`: Numeric values (e.g., storage size, timeout)
- `boolean`: True/false values (e.g., enable flags)

**Variable Properties:**
- `required`: Whether the parameter must be provided
- `default`: Default value if not provided
- `pattern`: Regex pattern for string validation (e.g., `^[a-z0-9-]+$`)
- `enum`: List of allowed values
- `description`: Human-readable description

### Step 5: Validate Manifest

```bash
npm run validate:manifest {blueprint-name}
# or validate all:
npm run validate:all
```

## Creating New Templates

### Step 1: Choose Template Name

Use kebab-case: `{resource-type}.tf.template` (e.g., `dynamodb-table.tf.template`)

### Step 2: Create Template File

Create `templates/{template-name}.tf.template` based on the original Terraform code.

### Step 3: Replace Values with Placeholders

Replace hardcoded values with `{{variable_name}}` placeholders:

```terraform
# Before
resource "aws_dynamodb_table" "this" {
  name         = "my-table"
  billing_mode = "PAY_PER_REQUEST"
}

# After
resource "aws_dynamodb_table" "this" {
  name         = "{{table_name}}"
  billing_mode = "{{billing_mode}}"
}
```

### Step 4: Handle Different Types

- **Strings**: Use as-is: `"{{table_name}}"`
- **Numbers**: No quotes: `{{allocated_storage}}`
- **Booleans**: No quotes: `{{enable_feature}}`
- **Conditional blocks**: Use Terraform `dynamic` blocks or conditionals

### Step 5: Add Comments

Include helpful comments explaining:
- What the template generates
- Important configuration notes
- Dependencies or prerequisites

Example:
```terraform
# modules/data/main.tf
# DynamoDB table
# Generated by blueprint-template-generator
```

## Naming Conventions

### Manifest Files
- Location: `blueprints/manifests/{blueprint-name}.yaml`
- Format: kebab-case matching blueprint directory name

### Snippet IDs
- Format: kebab-case
- Examples: `dynamodb-table`, `lambda-function`, `rds-module`

### Template Files
- Location: `templates/{resource-type}.tf.template`
- Format: kebab-case with `.tf.template` extension

### Variable Names
- Format: snake_case
- Examples: `table_name`, `db_identifier`, `enable_point_in_time_recovery`

## Variable Structure

### Required Variables

Always include:
- `name`: Variable name (snake_case)
- `type`: One of `string`, `number`, `boolean`
- `required`: `true` or `false`
- `description`: Human-readable description

### Optional Properties

- `default`: Default value (must match type)
- `pattern`: Regex pattern for string validation
- `enum`: Array of allowed values

### Example Variable Definition

```yaml
- name: db_identifier
  type: string
  required: true
  description: RDS instance identifier (e.g., myapp-dev-db)
  pattern: "^[a-z0-9-]+$"

- name: allocated_storage
  type: number
  required: false
  default: 20
  description: Initial storage allocation in GB

- name: multi_az
  type: boolean
  required: false
  default: false
  description: Enable Multi-AZ deployment
```

## Template Conventions

### Placeholder Format

Use double curly braces: `{{variable_name}}`

### Handling Optional Values

For optional blocks, use Terraform conditionals:

```terraform
dynamic "ttl" {
  for_each = "{{ttl_attribute_name}}" != "" ? [1] : []
  content {
    attribute_name = "{{ttl_attribute_name}}"
    enabled        = true
  }
}
```

### Preserving Terraform Structure

- Keep all Terraform syntax intact
- Only replace values, not structure
- Maintain proper indentation
- Include all necessary resource attributes

### Comments

- Add header comment with template name
- Include "Generated by blueprint-template-generator"
- Document any special configuration

## Validation Checklist

Before submitting a new manifest or template:

- [ ] Manifest file follows naming convention
- [ ] All required fields present (name, description, version, snippets)
- [ ] Each snippet has: id, name, template, variables
- [ ] Template file exists and is referenced correctly
- [ ] Variables have proper types and descriptions
- [ ] Required variables are marked as `required: true`
- [ ] Default values match variable types
- [ ] Pattern regex is valid (if used)
- [ ] Enum values match variable type (if used)
- [ ] Template uses correct placeholder format `{{variable_name}}`
- [ ] Template preserves Terraform syntax
- [ ] Manifest validates: `npm run validate:manifest {blueprint-name}`
- [ ] Setup script passes: `npm run setup`

## Testing

After creating a manifest and template:

1. **Validate structure:**
   ```bash
   npm run validate:manifest {blueprint-name}
   ```

2. **Test generation:**
   ```bash
   echo '{
     "blueprint": "{blueprint-name}",
     "snippet": "{snippet-id}",
     "params": { ... }
   }' | npm run generate
   ```

3. **Run tests:**
   ```bash
   npm test
   ```

## Examples

See existing manifests for reference:
- `blueprints/manifests/apigw-lambda-rds.yaml` - Complete example with dependencies
- `blueprints/manifests/apigw-lambda-dynamodb.yaml` - Simple example
- `templates/rds-module.tf.template` - Complex template with conditionals
- `templates/dynamodb-table.tf.template` - Simple template

## Getting Help

- Check existing manifests and templates for patterns
- Review test files in `__tests__/` for usage examples
- Run validation scripts to catch common errors
