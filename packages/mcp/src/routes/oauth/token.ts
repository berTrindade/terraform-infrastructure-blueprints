/**
 * OAuth token endpoint
 * 
 * POST /oauth/token
 * 
 * Exchanges authorization code for access token.
 * The code was generated by our server after exchanging Google's code.
 * This endpoint verifies PKCE and returns a JWT for MCP server access.
 */

import { Request, Response } from "express";
import { exchangeAuthorizationCode } from "../../services/oauth/authorization-code-store.js";
import { storeTokens } from "../../services/oauth/token-store.js";
import { randomUUID } from "node:crypto";

/**
 * Handle OAuth token exchange
 * 
 * Request body:
 * - grant_type: Must be "authorization_code"
 * - code: Authorization code from our server (NOT Google's code)
 * - redirect_uri: Must match authorization request
 * - code_verifier: PKCE code verifier
 * - client_id: OAuth client ID
 */
export async function handleToken(req: Request, res: Response): Promise<void> {
  const {
    grant_type,
    code,
    redirect_uri,
    code_verifier,
    client_id,
  } = req.body;

  // Validate grant type
  if (grant_type !== "authorization_code") {
    res.status(400).json({
      error: "unsupported_grant_type",
      error_description: "grant_type must be 'authorization_code'",
    });
    return;
  }

  if (!code || typeof code !== "string") {
    res.status(400).json({
      error: "invalid_request",
      error_description: "code is required",
    });
    return;
  }

  if (!code_verifier || typeof code_verifier !== "string") {
    res.status(400).json({
      error: "invalid_request",
      error_description: "code_verifier is required",
    });
    return;
  }

  try {
    // Exchange our authorization code for stored tokens
    // This also verifies the PKCE code_verifier
    const storedAuth = exchangeAuthorizationCode(code, code_verifier);
    
    if (!storedAuth) {
      res.status(400).json({
        error: "invalid_grant",
        error_description: "Invalid or expired authorization code, or invalid code_verifier",
      });
      return;
    }

    // Verify client_id matches if provided
    if (client_id && client_id !== storedAuth.clientId) {
      res.status(400).json({
        error: "invalid_grant",
        error_description: "client_id does not match",
      });
      return;
    }

    // Verify redirect_uri matches if provided
    if (redirect_uri && redirect_uri !== storedAuth.redirectUri) {
      res.status(400).json({
        error: "invalid_grant",
        error_description: "redirect_uri does not match",
      });
      return;
    }

    // Generate user ID (in production, use actual user ID from database)
    const userId = randomUUID();

    // Store tokens and generate JWT for MCP server
    const jwtToken = storeTokens(
      storedAuth.accessToken,
      storedAuth.refreshToken,
      userId,
      storedAuth.userInfo.email,
      storedAuth.userInfo.domain || "",
      3600 // 1 hour expiration
    );

    // Generate refresh token (a simple random token for now)
    const refreshToken = randomUUID();

    const tokenResponse = {
      access_token: jwtToken,
      token_type: "Bearer",
      expires_in: 3600,
      refresh_token: refreshToken,
      scope: "mcp:read mcp:write",
    };

    console.log("Token exchange successful:", {
      userEmail: storedAuth.userInfo.email,
      clientId: storedAuth.clientId,
      accessTokenLength: jwtToken.length,
      refreshTokenLength: refreshToken.length,
      responseJson: JSON.stringify(tokenResponse).substring(0, 100) + "...",
    });

    // Return token response
    res.json(tokenResponse);
  } catch (error) {
    // Ensure we always return JSON, never a Response object
    const errorMessage = error instanceof Error ? error.message : "Token exchange failed";
    const errorType = error instanceof Error ? error.name : "UnknownError";
    
    // Log error for debugging
    console.error("Token exchange error:", {
      type: errorType,
      message: errorMessage,
      stack: error instanceof Error ? error.stack : undefined,
    });
    
    res.status(400).json({
      error: "invalid_grant",
      error_description: errorMessage,
    });
  }
}

/**
 * Handle token validation request
 * 
 * POST /oauth/token/validate
 * 
 * Validates a token and returns user information
 */
export async function handleTokenValidate(req: Request, res: Response): Promise<void> {
  const authHeader = req.headers.authorization;
  const token = authHeader?.startsWith("Bearer ") ? authHeader.slice(7) : authHeader;

  if (!token) {
    res.status(401).json({
      valid: false,
      error: "Missing token",
    });
    return;
  }

  const { validateToken } = await import("../../services/oauth/token-store.js");
  const result = validateToken(token);

  if (!result.valid) {
    res.status(401).json(result);
    return;
  }

  res.json(result);
}
